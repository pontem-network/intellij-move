{
    parserClass="org.move.lang.MoveParser"
    psiClassPrefix="Mv"
    psiImplClassSuffix="Impl"

    implements="org.move.lang.core.psi.MvElement"
    extends="org.move.lang.core.psi.MvElementImpl"

    psiPackage="org.move.lang.core.psi"
    psiImplPackage="org.move.lang.core.psi.impl"
    parserUtilClass="org.move.lang.core.MoveParserUtil"

    elementTypeHolderClass="org.move.lang.MvElementTypes"

    elementTypeClass="org.move.lang.core.MvElementType"
    tokenTypeClass="org.move.lang.core.MvTokenType"

    extends(".*Expr")=Expr
    extends(".*Pat")=Pat
    extends("(Lambda|Ref|Path|Tuple|Unit|Parens)Type")=Type

    elementType(".+BinExpr")=BinaryExpr
    elementType(".+BinOp")=BinaryOp

    name(".+BinOp")="operator"
    name(".*Expr")="expression"
    name(".*Pat")="pattern"

    extraRoot(".*CodeFragmentElement")=true

    extends(".*Stmt")=Stmt

    consumeTokenMethod("((?!.*_with_recover).*_recover)|(.*_first)|(.*Expr)") = "consumeTokenFast"

    generateTokenAccessors=true

    tokens = [
        WHITESPACE='regexp:[ \n\t\r\f]'

        PLACEHOLDER_ADDRESS='regexp:\{\{[_a-zA-Z][_a-zA-Z0-9]*}}'
        DIEM_ADDRESS='regexp:0x[0-9a-fA-F]{1,40}'
        BECH32_ADDRESS='regexp:wallet1[A-Z0-9a-z&&[^boi1]]{6,83}'
        POLKADOT_ADDRESS='regexp:[1-9A-HJ-NP-Za-km-z]{40}[1-9A-HJ-NP-Za-km-z]*'

        BOOL_LITERAL='regexp:(true)|(false)'
        INTEGER_LITERAL='regexp:[0-9]+((u8)|(u16)|(u32)|(u64)|(u128)|(u256))?'
        HEX_INTEGER_LITERAL='regexp:0x[0-9a-fA-F]+((u8)|(u16)|(u32)|(u64)|(u128)|(u256))?'

        HEX_STRING_LITERAL='regexp:x\"([A-F0-9a-f]*)\"'
        BYTE_STRING_LITERAL='regexp:b"(.*)"'

        IDENTIFIER='regexp:[_a-zA-Z][_a-zA-Z0-9]*'
        FUNCTION_PATTERN_IDENT='regexp:[*_a-zA-Z][*_a-zA-Z0-9]*'

        L_BRACE          =  '{'
        R_BRACE          =  '}'
        L_BRACK          =  '['
        R_BRACK          =  ']'
        L_PAREN          =  '('
        R_PAREN          =  ')'
        COLON_COLON      =  '::'
        COLON           =  ':'
        SEMICOLON   =  ';'
        COMMA       =  ','
        LT            =  '<'
        GT         =  '>'
        AND = '&'
        OR = '|'
        EQ_EQ = '=='
        NOT_EQ = '!='
        EQ = '='
        DOT         =  '.'

        EXCL        =  '!'
        PLUS        =  '+'
        MINUS       =  '-'
        XOR         =  '^'
        MUL         =  '*'
        DIV         =  '/'
        MODULO         =  '%'

        AT         =  '@'
        HASH         =  '#'

        // Contextual tokens
        LT_EQ           = '<='
        LT_LT           = '<<'
        GT_EQ           = '>='
        GT_GT           = '>>'
        OR_OR           = '||'
        AND_AND         = '&&'
        EQ_EQ_GT        = '==>'
        LT_EQ_EQ_GT     = '<==>'
        DOT_DOT     = '..'

        ADDRESS     = 'address_kw'
        HAS     = 'has_kw'
        ENTRY     = 'entry_kw'
        INLINE     = 'inline_kw'
        FRIEND     = 'friend_kw'
        FOR     = 'for_kw'

        SCRIPT_KW     = 'script_kw'
        MODULE_KW     = 'module'
        STRUCT_KW     = 'struct_kw'
        CONST_KW     = 'const_kw'
        SCHEMA_KW     = 'schema_kw'

        LOCAL     = 'local_kw'
        GLOBAL     = 'global_kw'
        PRAGMA     = 'pragma_kw'
        POST     = 'post_kw'
        EMITS     = 'emits_kw'
        TO     = 'to_kw'
        APPLY     = 'apply_kw'
        INTERNAL     = 'internal_kw'
        EXCEPT     = 'except_kw'
        WITH     = 'with_kw'
        INCLUDE     = 'include_kw'
        INVARIANT     = 'invariant_kw'
        AXIOM     = 'axiom_kw'

        PACK     = 'pack_kw'
        UNPACK     = 'unpack_kw'
        UPDATE     = 'update_kw'

        ASSERT     = 'assert_kw'
        ASSUME     = 'assume_kw'
        MODIFIES     = 'modifies_kw'
        ENSURES     = 'ensures_kw'
        REQUIRES     = 'requires_kw'
        DECREASES     = 'decreases_kw'
        ABORTS_IF     = 'aborts_if_kw'
        ABORTS_WITH     = 'aborts_with_kw'

        CHOOSE     = 'choose_kw'
        MIN     = 'min_kw'

        FORALL     = 'forall_kw'
        EXISTS     = 'exists_kw'
        WHERE     = 'where_kw'
        IN     = 'in_kw'
    ]
}

// Naming convention:
//
//   * tokens are lowercase: for, if, identifier
//   * rules are PascalCase: StructItem
//   * recovery related rules are PascalCase_with_snake_suffix: Item_recover
File ::= (NamedAddressDef | Script | AddressDef | Module | ModuleSpec)*

QualPathCodeFragmentElement ::= FQModulePathIdent? TypeArgumentList?

Attr ::= '#' '[' <<non_empty_comma_sep_items AttrItem>> ']' { pin = 1 }
AttrItem ::= IDENTIFIER (AttrItemList | AttrItemInitializer)?
{
    implements = [
        "org.move.lang.core.resolve.ref.MvReferenceElement"
    ]
    mixin = "org.move.lang.core.psi.ext.MvAttrItemMixin"
}
AttrItemList ::= '(' <<non_empty_comma_sep_items AttrItem>>? ')' { pin = 1 }
//AttrItemArgument ::= IDENTIFIER ('=' Expr)?
//{
//    implements = [
//        "org.move.lang.core.resolve.ref.MvReferenceElement"
//    ]
//    mixin = "org.move.lang.core.psi.ext.MvAttrItemArgumentMixin"
//}
AttrItemInitializer ::= '=' Expr { pin = 1 }

NamedAddressDef ::= address IDENTIFIER '=' AddressRef ';' { pin = 3 }

Script ::= SCRIPT_KW ScriptBlock { pin = 1 }
ScriptBlock ::= '{' ScriptBlockItems '}' {
    pin = 1
    implements = [
        "org.move.lang.core.psi.MvImportsOwner"
    ]
}
private ScriptBlockItems ::= ScriptItem*

private ScriptItem ::= !('}' | <<eof>>) ScriptItem_item
{
    pin = 1
    recoverWhile = ScriptItem_recover
}
// top-level recovery
private ScriptItemFirst ::= use | CONST_KW | fun
private ScriptItem_recover ::= !('}' | <<eof>> | ScriptItemFirst)

private ScriptItem_item ::= UseStmt | Const | FunctionInner

private address ::= <<addressKeyword>>
private has ::= <<hasKeyword>>
private entry ::= <<entryKeyword>>
private inline ::= <<inlineKeyword>>
private schema ::= <<schemaKeyword>>

AddressDef ::= address AddressRef AddressBlock {
    pin = 1
    mixin = "org.move.lang.core.psi.ext.MvAddressDefMixin"
}
AddressBlock ::= '{' AddressBlockItems '}' { pin = 1 }
private AddressBlockItems ::= Module*
{
    recoverWhile = AddressBlockItems_recover
}
private AddressBlockItems_recover ::= !'}'

Module ::= Attr* MODULE_KW (AddressRef '::')? IDENTIFIER ModuleBlock
{
    pin = "MODULE_KW"
    name = "module declaration"
    implements = [
        "org.move.lang.core.psi.MvQualNamedElement"
        "org.move.lang.core.psi.MvNameIdentifierOwner"
        "org.move.lang.core.psi.ext.MvDocAndAttributeOwner"
    ]
    mixin = "org.move.lang.core.psi.ext.MvModuleMixin"
    stubClass = "org.move.lang.core.stubs.MvModuleStub"
    elementTypeFactory = "org.move.lang.core.stubs.StubsKt.factory"
    hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
}

ModuleBlock ::= '{' ModuleBlockItems '}'
{
    pin = 1
    implements = [
        "org.move.lang.core.psi.MvImportsOwner"
    ]
}
private ModuleBlockItems ::= ModuleItem*
private ModuleItem ::= !('}' | <<eof>>) ModuleItem_item
{
    pin = 1
    recoverWhile = Item_recover
}
// top-level recovery
private Item_first ::= use | public | native | fun | CONST_KW | STRUCT_KW | spec | friend | Attr | entry | inline
private Item_recover ::= !('}' | <<eof>> | Item_first)

private ModuleItem_item ::= UseStmt
                            | FriendDecl
                            | StructItem
                            | FunctionItem
                            | SpecFunctionItem
                            | Const
                            | Schema
                            | ModuleItemSpec
                            | ItemSpec

Const ::= Attr* CONST_KW IDENTIFIER TypeAnnotation Initializer ';'
{
    pin = "CONST_KW"
    implements = [
        "org.move.lang.core.psi.MvQualNamedElement"
        "org.move.lang.core.psi.MvNameIdentifierOwner"
        "org.move.lang.core.psi.ext.MvDocAndAttributeOwner"
        "org.move.lang.core.psi.MvTypeAnnotationOwner"
    ]
    mixin = "org.move.lang.core.psi.ext.MvConstMixin"
    stubClass = "org.move.lang.core.stubs.MvConstStub"
    elementTypeFactory = "org.move.lang.core.stubs.StubsKt.factory"
    hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Functions
///////////////////////////////////////////////////////////////////////////////////////////////////
fake SpecFunction ::= Attr* spec native? fun IDENTIFIER? TypeParameterList?
                        FunctionParameterList? ReturnType?
                        (';' | SpecCodeBlock)?
{
    implements = [
        "org.move.lang.core.psi.MvQualNamedElement"
        "org.move.lang.core.psi.MvFunctionLike"
        "org.move.lang.core.types.infer.MvInferenceContextOwner"
        "org.move.lang.core.psi.ScopeMslOnlyElement"
    ]
    mixin = "org.move.lang.core.psi.ext.MvSpecFunctionMixin"
    stubClass = "org.move.lang.core.stubs.MvSpecFunctionStub"
    elementTypeFactory = "org.move.lang.core.stubs.StubsKt.factory"
    hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
}
private SpecFunctionItem ::= SpecFunctionInner
                            | NativeSpecFunctionInner

SpecFunctionInner ::= Attr* spec fun IDENTIFIER TypeParameterList?
                       FunctionParameterList ReturnType? (<<msl SpecCodeBlock>> | ';')
{
    pin = 3
    elementType = SpecFunction
}
NativeSpecFunctionInner ::= Attr* spec (native fun) IDENTIFIER TypeParameterList?
                             FunctionParameterList ReturnType? ';'
{
    pin = 3
    elementType = SpecFunction
}

fake SpecInlineFunction ::= Attr* native? fun IDENTIFIER? TypeParameterList?
                                FunctionParameterList? ReturnType?
                                (SpecCodeBlock | ';')?
{
    implements = [
        "org.move.lang.core.psi.MvFunctionLike"
        "org.move.lang.core.types.infer.MvInferenceContextOwner"
        "org.move.lang.core.psi.ScopeMslOnlyElement"
    ]
    mixin = "org.move.lang.core.psi.ext.MvSpecInlineFunctionMixin"
    hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
}
//private SpecInlineFunctionImpl ::= SpecInlineFunctionInner
//                                    | NativeSpecInlineFunctionInner
//                                    | UninterpretedSpecInlineFunctionInner

SpecInlineFunctionInner ::= fun IDENTIFIER TypeParameterList?
                             FunctionParameterList ReturnType? (<<msl SpecCodeBlock>> | ';')
{
    pin = 1
    elementType = SpecInlineFunction
}
NativeSpecInlineFunctionInner ::= (native fun) IDENTIFIER TypeParameterList?
                                  FunctionParameterList ReturnType? ';'
{
    elementType = SpecInlineFunction
    pin = 1
}

SpecInlineFunctionStmt ::= SpecInlineFunctionInner
                            | NativeSpecInlineFunctionInner
{
    implements = [
        "org.move.lang.core.psi.MslOnlyElement"
    ]
}

fake Struct ::= Attr* native? STRUCT_KW IDENTIFIER? TypeParameterList? AbilitiesList?
                        (';' | StructBlock)?
{
    implements = [
        "org.move.lang.core.psi.MvQualNamedElement"
        "org.move.lang.core.psi.ext.MvDocAndAttributeOwner"
        "org.move.lang.core.psi.MvTypeParametersOwner"
        "org.move.lang.core.psi.MvNameIdentifierOwner"
    ]
    mixin = "org.move.lang.core.psi.ext.MvStructMixin"
    stubClass = "org.move.lang.core.stubs.MvStructStub"
    elementTypeFactory = "org.move.lang.core.stubs.StubsKt.factory"
}

private StructInnerFirst ::= STRUCT_KW
StructInner ::= Attr* StructInnerFirst IDENTIFIER TypeParameterList? AbilitiesList?
                            StructBlock
{
    pin = StructInnerFirst
    elementType = Struct
    hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
}
private NativeStructInnerFirst ::= native STRUCT_KW
NativeStructInner ::= Attr* NativeStructInnerFirst IDENTIFIER TypeParameterList? AbilitiesList? ';'
{
    pin = NativeStructInnerFirst
    elementType = Struct
    hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
}
private StructItem ::= StructInner | NativeStructInner

fake Function ::= Attr* native? FunctionVisibilityModifier? entry? inline?
                    fun? IDENTIFIER? TypeParameterList? FunctionParameterList?
                        ReturnType? AcquiresType?
                        (';' | CodeBlock)?
{
    implements = [
        "org.move.lang.core.psi.MvQualNamedElement"
        "org.move.lang.core.psi.MvFunctionLike"
        "org.move.lang.core.types.infer.MvInferenceContextOwner"
        "org.move.lang.core.psi.MvModificationTrackerOwner"
    ]
    mixin = "org.move.lang.core.psi.ext.MvFunctionMixin"
    stubClass = "org.move.lang.core.stubs.MvFunctionStub"
    elementTypeFactory = "org.move.lang.core.stubs.StubsKt.factory"
    hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
}

private FunctionInnerNoVisFirst ::= fun
private FunctionInnerVisFirst ::= FunctionModifierSetInner fun { pin = 1 }
private FunctionInnerFirst ::= FunctionInnerVisFirst | FunctionInnerNoVisFirst

FunctionInner ::= Attr* FunctionInnerFirst FunctionSignatureInner CodeBlock
{
    pin = FunctionInnerFirst
    elementType = Function
    hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
}

NativeFunctionInner ::= Attr* NativeFunctionModifierSetInner fun FunctionSignatureInner ';'
{
    pin = NativeFunctionModifierSetInner
    elementType = Function
    hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
}

private FunctionItem ::= NativeFunctionInner | FunctionInner

private FunctionSignatureInner ::= IDENTIFIER TypeParameterList?
                                    FunctionParameterList ReturnType? AcquiresType?
{
    recoverWhile = "FunctionSignatureInner_recover"
}
private FunctionSignatureInner_recover ::= !('{' | '}' | ';' | <<eof>> | Item_first)

private friend ::= <<friendKeyword>>
private for ::= <<forKeyword>>

private FunctionModifierSetInner ::= <<functionModifierSet FunctionVisibilityModifier>>
private NativeFunctionModifierSetInner ::= <<nativeFunctionModifierSet FunctionVisibilityModifier>>

FunctionVisibilityModifier ::= public ('(' (SCRIPT_KW | friend) ')')?

FunctionParameterList ::= '(' FunctionParameter_with_recover* ')' { pin = 1 }
private FunctionParameter_with_recover ::= !(')' | '{' | ';') FunctionParameter (',' | &')')
{
    pin = 1
    recoverWhile = FunctionParameter_recover
}
private FunctionParameter_recover ::= !(')' | '{' | ';' | IDENTIFIER)

FunctionParameter ::= BindingPat TypeAnnotation {
    pin = 1
    implements = [
        "org.move.lang.core.psi.MvTypeAnnotationOwner"
    ]
    mixin = "org.move.lang.core.psi.ext.MvFunctionParameterMixin"
}

// u8 | (u8,) | (u8, u8) | (u8, u8,)
// tuples only allowed as a return types
ReturnType ::= ':' ReturnTypeItem_with_recover { pin = 1 }
private ReturnTypeItem_with_recover ::= Type
{
    pin = 1
    recoverWhile = ReturnTypeItem_recover
}
private ReturnTypeItem_recover ::= !( '{' | ';' | acquires )

// acquires T, Record
AcquiresType ::= acquires AcquiresType_items { pin = 1 }
private AcquiresType_items ::= <<non_empty_comma_sep_items PathType>>
{
    recoverWhile = AcquiresType_items_recover
}
private AcquiresType_items_recover ::= !(';' | '{')

AbilitiesList ::= has <<non_empty_comma_sep_items Ability>> { pin = 1 }
Ability ::= copy | IDENTIFIER
{
    name = "ability"
}

StructBlock ::= '{' StructField_with_recover* '}' { pin = 1 }
private StructField_with_recover ::= !'}' StructField (',' | &'}')
{
    pin = 1
    recoverWhile = StructField_recover
}
private StructField_recover ::= !('}' | IDENTIFIER)

StructField ::= Attr* IDENTIFIER TypeAnnotation &(',' | '}')
{
    pin = 2
    implements = [
        "org.move.lang.core.psi.MvMandatoryNameIdentifierOwner"
        "org.move.lang.core.psi.ext.MvDocAndAttributeOwner"
        "org.move.lang.core.psi.MvTypeAnnotationOwner"
    ]
    mixin = "org.move.lang.core.psi.ext.MvStructFieldMixin"
    hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
}

FriendDecl ::= Attr* friend FQModuleRef ';'
{
    pin = "friend"
    implements = [ "org.move.lang.core.psi.ext.MvDocAndAttributeOwner" ]
}

UseStmt ::= Attr* use (ItemUseSpeck | ModuleUseSpeck) ';' {
    pin = "use"
    implements = [ "org.move.lang.core.psi.ext.MvDocAndAttributeOwner" ]
}
ModuleUseSpeck ::= (AddressRef !'::') | FQModuleRef UseAlias?
{
    name = "qual path to module"
    implements = [
        "org.move.lang.core.psi.MvNamedElement"
//        "org.move.lang.core.psi.MvUseSpeck"
    ]
    mixin = "org.move.lang.core.psi.ext.MvModuleUseSpeckMixin"
}
ItemUseSpeck ::= FQModuleRef '::' (UseItem | UseItemGroup)
{
    pin = 2
    name = "qual path to imported item"
//    implements = [
//        "org.move.lang.core.psi.MvUseSpeck"
//    ]
}

UseItemGroup ::= '{' <<non_empty_comma_sep_items MultiItemUse_member_with_recovery>>? '}'
{
    pin = 1
}
private MultiItemUse_member_with_recovery ::= !('}' | ';' | <<eof>>) UseItem
{
    pin = 1
}

UseItem ::= IDENTIFIER UseAlias?
{
    pin = 1
    name = "item name"
    implements = [
        "org.move.lang.core.psi.MvNamedElement"
        "org.move.lang.core.resolve.ref.MvMandatoryReferenceElement"
    ]
    mixin = "org.move.lang.core.psi.ext.MvUseItemMixin"
}
UseAlias ::= as IDENTIFIER
{
    pin = 1
    implements = [ "org.move.lang.core.psi.MvNameIdentifierOwner" ]
    mixin = "org.move.lang.core.psi.ext.MvUseAliasMixin"
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Types
///////////////////////////////////////////////////////////////////////////////////////////////////
TypeAnnotation ::= ':' Type {
    pin = 1
    name = "type annotation"
}

Type ::= RefType | PathType | TupleType | LambdaType | UnitType | ParensType
ParensType ::= '(' (Type !',') ')' { pin = 2 }

UnitType ::= '(' ')'
RefType ::= RefTypeStart Type
{
    pin = 1
}
RefTypeStart ::= '&' mut?

PathType ::= Path
{
    name = "type"
}

TupleType ::= '(' Type ',' (Type ','?)* ')' { pin = 3 }

LambdaType ::= '|' <<non_empty_comma_sep_items LambdaTypeParam>>? '|' Type? { pin = 1 }
LambdaTypeParam ::= Type

TypeParameterList ::= '<' TypeParameter_with_recover* '>'
{
    pin = 1
    name = "type parameters"
}
private TypeParameter_with_recover ::= !'>' TypeParameterImpl (',' | &'>')
{
    pin = 1
    recoverWhile = TypeParameter_recover
}
private TypeParameter_recover ::= !('>' | '(' | '{' | phantom | IDENTIFIER)

fake TypeParameter ::= phantom? IDENTIFIER? TypeParamBound? {
    pin = 2
    implements = [
        "org.move.lang.core.psi.MvNameIdentifierOwner"
    ]
    mixin = "org.move.lang.core.psi.ext.MvTypeParameterMixin"
}

private TypeParameterImpl ::= PlainTypeParameter | PhantomTypeParameter
PlainTypeParameter ::= IDENTIFIER TypeParamBound? { pin = 1 elementType = TypeParameter }
PhantomTypeParameter ::= phantom IDENTIFIER TypeParamBound? { pin = 1 elementType = TypeParameter }

TypeParamBound ::= ':' TypeParamBound_items
{
    pin = 1
}
private TypeParamBound_items ::= Ability ( '+' Ability )*
{
    recoverWhile = TypeParamBound_items_recover
}
private TypeParamBound_items_recover ::= !('>' | ',')

TypeArgumentList ::= '<' <<non_empty_comma_sep_items (TypeArgument &(','|'>'))>>? '>' {
    name = "type arguments"
}
TypeArgument ::= Type

///////////////////////////////////////////////////////////////////////////////////////////////////
// Patterns (destructuring)
///////////////////////////////////////////////////////////////////////////////////////////////////
Pat ::= TuplePat
        | StructPat
        | WildPat
        | BindingPat

WildPat ::= '_'

BindingPat ::= IDENTIFIER {
    implements = [
        "org.move.lang.core.psi.MvMandatoryNameIdentifierOwner"
    ]
    mixin = "org.move.lang.core.psi.ext.MvBindingPatMixin"
}

TuplePat ::= '(' <<non_empty_comma_sep_items Pat>>? ')'

StructPat ::= Path StructPatFieldsBlock
StructPatFieldsBlock ::= '{' StructPatField_with_recover* '}' { pin = 1 }

private StructPatField_with_recover ::= !'}' StructPatField (',' | &'}')
{
    pin = 1
    recoverWhile = StructPatField_recover

}
private StructPatField_recover ::= !('}' | IDENTIFIER)

StructPatField ::= (BindingPat !':') | (IDENTIFIER StructPatFieldBinding)
{
    implements = [
        "org.move.lang.core.resolve.ref.MvStructPatFieldReferenceElement"
        "org.move.lang.core.resolve.ref.MvStructRefField"
    ]
    mixin = "org.move.lang.core.psi.ext.MvStructPatFieldMixin"
}
StructPatFieldBinding ::= ':' Pat

///////////////////////////////////////////////////////////////////////////////////////////////////
// Stmts
///////////////////////////////////////////////////////////////////////////////////////////////////
Stmt ::= LetMoveStmt | ExprStmt

SpecExprStmt ::= (SpecExpr_item !'}') ';' { pin = 1 }
private SpecExpr ::= SpecExprStmt_items | Expr
private SpecExpr_item ::= SpecExprStmt_items | ExprStmt_expr
{
    recoverWhile = SpecExprStmt_recover
}
private SpecExprStmt_recover ::= !(';' | '}' | SpecExpr_first | Expr_first)
private SpecExprStmt_first ::= let | if | while
                                    | include | apply | pragma | emits | assume | assert | ensures
                                    | axiom | modifies | aborts_if | aborts_with | requires | invariant

private SpecExprStmt_items ::= AssumeSpecExpr | AssertSpecExpr | AbortsIfSpecExpr | AbortsWithSpecExpr
                | RequiresSpecExpr | DecreasesSpecExpr
                | EnsuresSpecExpr | ModifiesSpecExpr | InvariantSpecExpr | AxiomSpecExpr
                | EmitsSpecExpr

private post ::= <<postKeyword>>
fake LetStmt ::= let post? Pat? TypeAnnotation? Initializer? ';'?
{
    implements = ["org.move.lang.core.psi.MvTypeAnnotationOwner"]
}

LetMoveStmt ::= let Pat TypeAnnotation? Initializer? ';'
{
    pin = 1
    elementType = LetStmt
}
LetMslStmt ::= (let post?) Pat TypeAnnotation? Initializer? ';'
{
    pin = 1
    elementType = LetStmt
}

ExprStmt ::= (ExprStmt_expr !('}')) ';' { pin = 1 }
private ExprStmt_expr ::= ItemSpecBlockExpr | Expr
{
    recoverWhile = "ExprStmt_recover"
}
private ExprStmt_recover ::= !(';' | '}' | <<mslOnly SpecExpr_first>> | Expr_first)
private Expr_first ::= let | if | while | loop | continue | break | return | spec
                        | copy | move | abort
//                        | (<<VECTOR_IDENTIFIER>> ('<' | '['))
                        | IDENTIFIER
                        | '*' | '&' | '!' | '|' | '{' | '('
                        | AnyLitToken_first
                        | (AddressRef '::')
private SpecExpr_first ::= include | apply | pragma | emits | assume | assert | ensures
                            | axiom | modifies | aborts_if | aborts_with | requires
                            | invariant | choose | decreases | update

///////////////////////////////////////////////////////////////////////////////////////////////////
// Blocks
///////////////////////////////////////////////////////////////////////////////////////////////////
private AnyBlock ::= CodeBlock | InlineBlock

InlineBlock ::= Expr

CodeBlockExpr ::= CodeBlock
CodeBlock ::= '{' CodeBlock_items '}'
{
    pin = 1
    implements = [
        "org.move.lang.core.psi.MvImportsOwner"
        "org.move.lang.core.psi.AnyBlock"
    ]
    mixin = "org.move.lang.core.psi.ext.MvCodeBlockMixin"
}

private CodeBlock_items ::= UseStmt*
                            Stmt*
                            ExprStmt_expr?
{
    recoverWhile = "CodeBlock_items_recover"
}
private CodeBlock_items_recover ::= !('}' | <<eof>>)

///////////////////////////////////////////////////////////////////////////////////////////////////
// Expressions
///////////////////////////////////////////////////////////////////////////////////////////////////
// from lowest to highest
Expr ::= AssignmentExpr
        | RangeExpr
        | (ForallQuantExpr | ExistsQuantExpr | ChooseQuantExpr)
        | CastExpr
        | ImplyBinExpr_items
        | OrBinExpr
        | AndBinExpr
        | LogicalEqExpr_items
        | BitOrBinExpr
        | BitXorBinExpr
        | BitAndBinExpr
        | (LeftShiftBinExpr | RightShiftBinExpr)
        | AddExpr_items
        | MulExpr_items
        | ControlFlowExpr_items
        | UnaryExpr
        | BorrowExpr
        | AtomExpr

fake BinaryExpr ::= Expr BinaryOp Expr {
    methods = [
        left="/Expr[0]"
        right="/Expr[1]"
    ]
    mixin = "org.move.lang.core.psi.ext.MvBinaryExprMixin"
}

//noinspection BnfUnusedRule
fake BinaryOp ::= '<==>' | '==>' | '='
                    | '==' | '!='
                    | '<' | '>' | '<=' | '>='
                    | '<<' | '>>'
                    | '+' | '-' | '*' | '/' | '%'
                    | '||' | '&&' | '|' | '&' | '^'


private MulExpr_items ::= DivBinExpr | MulBinExpr | ModBinExpr
private AddExpr_items ::= PlusBinExpr | MinusBinExpr
private LogicalEqExpr_items ::= EqualsBinExpr | NotEqualsBinExpr | LessEqualsBinExpr | LessBinExpr | GreaterEqualsBinExpr | GreaterBinExpr

private ControlFlowExpr_items ::= IfExpr | LoopExpr | WhileExpr | ForExpr
private UnaryExpr ::= CopyExpr | MoveExpr | DerefExpr | BangExpr
                      | ReturnExpr | ContinueExpr | BreakExpr | AbortExpr
private AtomExpr ::=
                    AnnotatedExpr
                    | TupleLitOrParenExpr
                    | StructLitExpr
                    | VectorLitExpr
                    | DotExpr
                    | IndexExpr
                    | (CallExpr | AssertBangExpr)
                    | RefExpr
                    | LambdaExpr
                    | LitExpr
                    | CodeBlockExpr


CastExpr ::= Expr as Type

private AnnotatedExpPrefix ::= '(' Expr ':'
AnnotatedExpr ::= AnnotatedExpPrefix Type ')' { pin = 1 }

EqualsBinExpr ::= Expr (!eqeq_gt EqualsBinOp) Expr
NotEqualsBinExpr ::= Expr NotEqualsBinOp Expr

EqualsBinOp ::= '=='
NotEqualsBinOp ::= '!='

// booleans
OrBinExpr ::= Expr OrBinOp Expr
AndBinExpr ::= Expr AndBinOp Expr

OrBinOp ::= oror
AndBinOp ::= andand

LessBinExpr ::= Expr (!(ltlt | lt_eqeq_gt) LessBinOp) Expr
GreaterBinExpr ::= Expr (!gtgt GreaterBinOp) Expr
LessEqualsBinExpr ::= Expr LessEqualsBinOp Expr
GreaterEqualsBinExpr ::= Expr GreaterEqualsBinOp Expr

LessBinOp ::= '<'
GreaterBinOp ::= '>'
LessEqualsBinOp ::= lteq
GreaterEqualsBinOp ::= gteq

// bitwise ops
BitOrBinExpr ::= Expr (!oror BitOrBinOp) Expr
BitAndBinExpr ::= Expr (!andand BitAndBinOp) Expr
BitXorBinExpr ::= Expr BitXorBinOp Expr

BitOrBinOp ::= '|'
BitAndBinOp ::= '&'
BitXorBinOp ::= '^'

// arithmetic
MulBinExpr ::= Expr MulBinOp Expr
DivBinExpr ::= Expr DivBinOp Expr
PlusBinExpr ::= Expr PlusBinOp Expr
MinusBinExpr ::= Expr MinusBinOp Expr
ModBinExpr ::= Expr ModBinOp Expr

MulBinOp ::= '*'
DivBinOp ::= '/'
PlusBinOp ::= '+'
MinusBinOp ::= '-'
ModBinOp ::= '%'

// bit shifts
LeftShiftBinExpr ::= Expr LeftShiftBinOp Expr
RightShiftBinExpr ::= Expr RightShiftBinOp Expr

LeftShiftBinOp ::= ltlt
RightShiftBinOp ::= gtgt

// imply
private ImplyBinExpr_items ::= ImplyBinExpr | PartialImplyBinExpr
ImplyBinExpr ::= Expr ImplyBinOp Expr
PartialImplyBinExpr ::= Expr PartialImplyBinOp Expr

ImplyBinOp ::= <<includeStmtModeFalse>> <<mslOnly eqeq_gt>>
PartialImplyBinOp ::= <<mslOnly lt_eqeq_gt>>

BangExpr ::= '!' Expr
DerefExpr ::= '*' Expr

CopyExpr ::= copy Expr
MoveExpr ::= move Expr

ReturnExpr ::= return Expr?

AbortExpr ::= abort Expr
BreakExpr ::= break
ContinueExpr ::= continue

VectorLitExpr ::= <<VECTOR_IDENTIFIER>> ('<' TypeArgument '>')? VectorLitItems
VectorLitItems ::= '[' <<non_empty_comma_sep_items Expr>>? ']'
{
    pin = 1
}

StructLitExpr ::= <<includeStmtModeFalse>> Path StructLitFieldsBlock
{
    implements = ["org.move.lang.core.psi.PathExpr"]
}
StructLitFieldsBlock ::= '{' StructLitField_with_recover* '}' { pin = 1 }

private StructLitField_with_recover ::= !'}' StructLitField (',' | &'}')
{
    pin = 1
    recoverWhile = StructLitField_recover
}
private StructLitField_recover ::= !('}' | IDENTIFIER)

StructLitField ::= IDENTIFIER StructLitFieldInit?
{
    implements = [
        "org.move.lang.core.resolve.ref.MvStructFieldLitReferenceElement"
        "org.move.lang.core.resolve.ref.MvStructRefField"
    ]
    mixin = "org.move.lang.core.psi.ext.MvStructLitFieldMixin"
}

private StructLitFieldInit ::= ':' Expr { pin = 1 }

fake TupleLitExpr ::= '(' Expr+ ')' {
    pin = 2
}
fake ParensExpr ::= '(' Expr ')' {
    pin = 1
}

TupleLitOrParenExpr ::= '(' Expr (TupleLitExprUpper | ')') {
    pin = 1
    elementType = ParensExpr
}
upper TupleLitExprUpper ::= ',' [ Expr (',' Expr)* ','? ] ')' {
    pin = 1
    elementType = TupleLitExpr
}

LambdaExpr ::= '|' <<non_empty_comma_sep_items BindingPat>> '|' Expr { pin = 1 }

RangeExpr ::= Expr dotdot Expr { pin = 2 }


private HEX_INTEGER_LITERAL ::= <<hexIntegerLiteral>>
LitExpr ::= HEX_INTEGER_LITERAL
                | BOOL_LITERAL
                | INTEGER_LITERAL
                | HEX_STRING_LITERAL
                | BYTE_STRING_LITERAL
                | AddressLit

private AnyLitToken_first ::= HEX_INTEGER_LITERAL
                                  | BOOL_LITERAL
                                  | INTEGER_LITERAL
                                  | HEX_STRING_LITERAL
                                  | BYTE_STRING_LITERAL
                                  | '@'

AddressLit ::= '@' AddressRef { pin = 1 }

CallExpr ::= (Path &'(') ValueArgumentList {
    pin = 1
    implements = ["org.move.lang.core.psi.PathExpr"]
}
ValueArgumentList ::= '(' ValueArgumentList_items? ')' {
    pin = 1
}
private ValueArgumentList_items ::= ValueArgument (',' ValueArgument)* ','?

ValueArgument ::= !')' Expr &(',' | ')') {
    pin = 1
    recoverWhile = ValueArgument_recover
}
private ValueArgument_recover ::= !(<<mslOnly SpecExpr_first>> | Expr_first | ')' | '}' | ';' | ',')

IfExpr ::= if Condition AnyBlock ElseBlock? { pin = 1 }

Condition ::= '(' ConditionBody ')' { pin = 1 }
private ConditionBody ::= Expr { recoverWhile = "ConditionBody_recover" }
private ConditionBody_recover ::= !')'

ElseBlock ::= else AnyBlock { pin = 1 }

LoopExpr ::= loop AnyBlock {
    pin = 1
    implements = [ "org.move.lang.core.psi.MvLoopLike" ]
}
WhileExpr ::= while Condition AnyBlock {
    pin = 1
    implements = [ "org.move.lang.core.psi.MvLoopLike" ]
}
ForExpr ::= for ForIterCondition AnyBlock {
    pin = 1
    implements = [ "org.move.lang.core.psi.MvLoopLike" ]
}
ForIterCondition ::= '(' BindingPat in Expr ')' {
    pin = 1
}

AssignmentExpr ::= Expr Initializer { rightAssociative = true }
Initializer ::= '=' Expr { pin = 1 }

BorrowExpr ::= '&' mut? Expr

DotExpr ::= Expr DotExpr_field
// Do not inline this rule, it breaks expression parsing
private DotExpr_field ::= '.' (!'.') StructDotField {
    pin = 2
    consumeTokenMethod = "consumeTokenFast"
}
StructDotField ::= !(<<VECTOR_IDENTIFIER>> ('[' | '<')) IDENTIFIER !('(' | '::' | '!' | '{')
{
    implements = ["org.move.lang.core.resolve.ref.MvMandatoryReferenceElement"]
    mixin = "org.move.lang.core.psi.ext.MvStructDotFieldMixin"
}

IndexExpr ::= Expr IndexArg
// Do not inline this rule, it breaks expression parsing
private IndexArg ::= '[' Expr ']'

RefExpr ::= Path !'{' {
    implements = ["org.move.lang.core.psi.PathExpr"]
}

Path ::= (ModulePathIdent | FQModulePathIdent | LocalPathIdent) TypeArgumentList?
{
    implements = ["org.move.lang.core.resolve.ref.MvPathReferenceElement"]
    mixin = "org.move.lang.core.psi.ext.MvPathMixin"
}

private LocalPathIdent ::= IDENTIFIER
private ModulePathIdent ::= ModuleRef ('::' !(IDENTIFIER '::')) IDENTIFIER
{
    pin = 2
}
private FQModulePathIdent ::= FQModuleRef '::' IDENTIFIER
{
    pin = 1
}

ModuleRef ::= IDENTIFIER | FQModuleRef
{
    implements = ["org.move.lang.core.resolve.ref.MvReferenceElement"]
    mixin = "org.move.lang.core.psi.ext.MvModuleRefMixin"
}

FQModuleRef ::= AddressRef '::' IDENTIFIER
{
    pin = 2
    extends = ModuleRef
    implements = [
        "org.move.lang.core.resolve.ref.MvFQModuleReferenceElement"
    ]
    mixin = "org.move.lang.core.psi.ext.MvFQModuleRefMixin"
}

AddressRef ::= NamedAddress
                | DIEM_ADDRESS
                | INTEGER_LITERAL
                | PLACEHOLDER_ADDRESS
                | BECH32_ADDRESS
                | POLKADOT_ADDRESS
NamedAddress ::= IDENTIFIER
{
    implements = ["org.move.lang.core.resolve.ref.NamedAddressReferenceElement"]
    mixin = "org.move.lang.core.psi.ext.MvNamedAddressMixin"
}

/// Macros
AssertBangExpr ::= <<ASSERT_IDENTIFIER>> '!' ValueArgumentList { pin = 2 }
//AssertBangExpr ::= MacroIdent ValueArgumentList { pin = 1 }
//MacroIdent ::= IDENTIFIER '!'

private assert ::= <<assertKeyword>>
private assume ::= <<assumeKeyword>>
private modifies ::= <<modifiesKeyword>>
private requires ::= <<requiresKeyword>>
private decreases ::= <<decreasesKeyword>>
private ensures ::= <<ensuresKeyword>>
private aborts_if ::= <<abortsIfKeyword>>
private aborts_with ::= <<abortsWithKeyword>>
private include ::= <<includeKeyword>>
private choose ::= <<chooseKeyword>>
private min ::= <<minKeyword>>

private invariant ::= <<invariantKeyword>>
private axiom ::= <<axiomKeyword>>
private forall ::= <<forallKeyword>>
private exists ::= <<existsKeyword>>
private with ::= <<withKeyword>>
private where ::= <<whereKeyword>>
private in ::= <<inKeyword>>
private update ::= <<updateKeyword>>

private pragma ::= <<pragmaKeyword>>
private local ::= <<localKeyword>>
private global ::= <<globalKeyword>>
private emits ::= <<emitsKeyword>>
private to ::= <<toKeyword>>
private apply ::= <<applyKeyword>>
private except ::= <<exceptKeyword>>

ModuleSpec ::= Attr* spec FQModuleRef ModuleSpecBlock
{
    pin = "spec"
    name = "module spec declaration"
    mixin = "org.move.lang.core.psi.ext.MvModuleSpecMixin"
    stubClass = "org.move.lang.core.stubs.MvModuleSpecStub"
    elementTypeFactory = "org.move.lang.core.stubs.StubsKt.factory"
    hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
}
ModuleSpecBlock ::= '{' ModuleSpecBlock_item_with_recover* '}'
{
    pin = 1
    implements = [
        "org.move.lang.core.psi.MvImportsOwner"
        "org.move.lang.core.psi.ScopeMslOnlyElement"
        "org.move.lang.core.psi.AnyBlock"
    ]
}

private ModuleSpecBlock_item_with_recover ::= !('}' | <<eof>>) ModuleSpecBlock_item
{
    pin = 1
    recoverWhile = ModuleSpecBlock_item_recover
}
private ModuleSpecBlock_item ::= UseStmt | SpecFunctionItem | Schema | ModuleItemSpec | ItemSpec
private ModuleSpecBlock_item_recover ::= !('}' | <<eof>> | spec | use)

ModuleItemSpec ::= spec MODULE_KW <<msl SpecCodeBlock>>
{
    pin = 2
    implements = [
        "org.move.lang.core.types.infer.MvInferenceContextOwner"
        "org.move.lang.core.psi.ScopeMslOnlyElement"
    ]
}
ItemSpec ::= (spec !MODULE_KW) ItemSpecRef ItemSpecSignature? <<msl SpecCodeBlock>>
{
    pin = 1
    implements = [
        "org.move.lang.core.types.infer.MvInferenceContextOwner"
        "org.move.lang.core.psi.MvModificationTrackerOwner"
        "org.move.lang.core.psi.ScopeMslOnlyElement"
    ]
    mixin = "org.move.lang.core.psi.ext.MvItemSpecMixin"
}
ItemSpecSignature ::= ItemSpecTypeParameterList? ItemSpecFunctionParameterList ReturnType?
{
    pin = ItemSpecFunctionParameterList
    name = "function signature"
}

ItemSpecTypeParameterList ::= '<' ItemSpecTypeParameter_with_recover* '>'
{
    pin = 1
}
private ItemSpecTypeParameter_with_recover ::= !'>' ItemSpecTypeParameter (',' | &'>')
{
    pin = 1
    recoverWhile = ItemSpecTypeParameter_recover
}
private ItemSpecTypeParameter_recover ::= !('>' | '(' | '{' | phantom | IDENTIFIER)

ItemSpecTypeParameter ::= IDENTIFIER TypeParamBound? {
    pin = 1
    implements = [
        "org.move.lang.core.resolve.ref.MvItemSpecParameterReferenceElement"
    ]
    mixin = "org.move.lang.core.psi.ext.MvItemSpecTypeParameterMixin"
}

ItemSpecFunctionParameterList ::= '(' ItemSpecFunctionParameter_with_recover* ')' { pin = 1 }
private ItemSpecFunctionParameter_with_recover ::= !(')' | '{' | ';') ItemSpecFunctionParameter (',' | &')')
{
    pin = 1
    recoverWhile = ItemSpecFunctionParameter_recover
}
private ItemSpecFunctionParameter_recover ::= !(')' | '{' | ';' | IDENTIFIER)

ItemSpecFunctionParameter ::= IDENTIFIER TypeAnnotation {
    pin = 1
    implements = [
        "org.move.lang.core.resolve.ref.MvItemSpecParameterReferenceElement"
        "org.move.lang.core.psi.MvTypeAnnotationOwner"
    ]
    mixin = "org.move.lang.core.psi.ext.MvItemSpecFunctionParameterMixin"
}

ItemSpecRef ::= IDENTIFIER
{
    implements = ["org.move.lang.core.resolve.ref.MvMandatoryReferenceElement"]
    mixin = "org.move.lang.core.psi.ext.MvItemSpecRefMixin"
}

Schema ::= (spec schema) IDENTIFIER TypeParameterList? <<msl SpecCodeBlock>> {
    pin = 1
    implements = [
        "org.move.lang.core.psi.MvTypeParametersOwner"
        "org.move.lang.core.psi.MvQualNamedElement"
        "org.move.lang.core.psi.MvNameIdentifierOwner"
        "org.move.lang.core.types.infer.MvInferenceContextOwner"
        "org.move.lang.core.psi.ScopeMslOnlyElement"
    ]
    mixin = "org.move.lang.core.psi.ext.MvSchemaMixin"
    stubClass = "org.move.lang.core.stubs.MvSchemaStub"
    elementTypeFactory = "org.move.lang.core.stubs.StubsKt.factory"
}

ItemSpecBlockExpr ::= spec <<msl SpecCodeBlock>> {
    implements = [
        "org.move.lang.core.psi.ScopeMslOnlyElement"
    ]
}

SpecCodeBlock ::= '{' ItemSpecBlock_items '}'
{
    pin = 1
    implements = [
        "org.move.lang.core.psi.MvImportsOwner"
        "org.move.lang.core.psi.AnyBlock"
        "org.move.lang.core.psi.MslOnlyElement"
    ]
    mixin = "org.move.lang.core.psi.ext.MvSpecCodeBlockMixin"
}
private ItemSpecBlock_items ::= (SpecStmt | ExprStmt)* (SpecExprStmt_items | ExprStmt_expr)?
{
    recoverWhile = ItemSpecBlock_items_recover
}
private ItemSpecBlock_items_recover ::= !('}' | <<eof>>)

private SpecStmt ::= UseStmt
                       | SchemaFieldStmtImpl
                       | GlobalVariableStmt
                       | SpecInlineFunctionStmt
                       | PragmaSpecStmt
                       | IncludeStmt
                       | UpdateSpecStmt
                       | ApplySchemaStmt
                       | LetMslStmt
                       | SpecExprStmt

fake SchemaFieldStmt ::= local? BindingPat TypeAnnotation ';'
{
    implements = [
        "org.move.lang.core.psi.MvTypeAnnotationOwner"
        "org.move.lang.core.psi.MslOnlyElement"
    ]
}

private SchemaFieldStmtImpl ::= SchemaFieldStmt_local | SchemaFieldStmt_simple

SchemaFieldStmt_simple ::= BindingPat TypeAnnotation ';' {
    pin = 2
    elementType = SchemaFieldStmt
}
SchemaFieldStmt_local ::= local BindingPat TypeAnnotation ';' {
    pin = 1
    elementType = SchemaFieldStmt
}

GlobalVariableStmt ::= global IDENTIFIER TypeParameterList? TypeAnnotation ('=' Expr)? ';'
{
    pin = 1
    implements = [
        "org.move.lang.core.psi.MvNameIdentifierOwner"
        "org.move.lang.core.psi.MvTypeAnnotationOwner"
        "org.move.lang.core.psi.MslOnlyElement"
    ]
    mixin = "org.move.lang.core.psi.ext.MvGlobalVariableMixin"
}

PragmaSpecStmt ::= pragma <<non_empty_comma_sep_items PragmaAttribute>> ';' {
    pin = 1
    implements = [ "org.move.lang.core.psi.MslOnlyElement" ]
}
PragmaAttribute ::= IDENTIFIER ('=' Expr)? {
    implements = [ "org.move.lang.core.psi.MslOnlyElement" ]
}

AbortsIfSpecExpr ::= aborts_if SpecPropertyList? Expr AbortsIfWith? {
    pin = 1
    implements = [
        "org.move.lang.core.psi.MvBoolSpecExpr"
        "org.move.lang.core.psi.MslOnlyElement"
    ]
}
AbortsIfWith ::= with Expr {
    pin = 1
    implements = [ "org.move.lang.core.psi.MslOnlyElement" ]
}

AbortsWithSpecExpr ::= aborts_with SpecPropertyList? <<non_empty_comma_sep_items Expr>> {
    pin = 1
    implements = [ "org.move.lang.core.psi.MslOnlyElement" ]
}

AssertSpecExpr ::= assert SpecPropertyList? Expr {
    pin = 1
    implements = [
        "org.move.lang.core.psi.MvBoolSpecExpr"
        "org.move.lang.core.psi.MslOnlyElement"
    ]
}
AssumeSpecExpr ::= assume SpecPropertyList? Expr {
    pin = 1
    implements = [
        "org.move.lang.core.psi.MvBoolSpecExpr"
        "org.move.lang.core.psi.MslOnlyElement"
    ]
}
EnsuresSpecExpr ::= ensures SpecPropertyList? SpecExpr {
    pin = 1
    implements = [
        "org.move.lang.core.psi.MvBoolSpecExpr"
        "org.move.lang.core.psi.MslOnlyElement"
    ]
}
RequiresSpecExpr ::= requires SpecPropertyList? Expr {
    pin = 1
    implements = [
        "org.move.lang.core.psi.MvBoolSpecExpr"
        "org.move.lang.core.psi.MslOnlyElement"
    ]
}
DecreasesSpecExpr ::= decreases SpecPropertyList? Expr {
    pin = 1
    implements = [
        "org.move.lang.core.psi.MslOnlyElement"
    ]
}

ModifiesSpecExpr ::= modifies SpecPropertyList? Expr {
    pin = 1
    implements = [
        "org.move.lang.core.psi.MslOnlyElement"
    ]
}

IncludeStmt ::= include SpecPropertyList? IncludeItem ';' {
    pin = 1
    implements = [
        "org.move.lang.core.psi.MslOnlyElement"
    ]
}

UpdateSpecStmt ::= update UpdateExpr_items '=' Expr ';' {
    pin = 1
    implements = [
        "org.move.lang.core.psi.MslOnlyElement"
    ]
}
private UpdateExpr_items ::= UnaryExpr | BorrowExpr | AtomExpr

IncludeItem ::= SchemaIncludeItem | AndIncludeItem | IfElseIncludeItem | ImplyIncludeItem
{
    implements = [
        "org.move.lang.core.psi.MslOnlyElement"
    ]
}

SchemaIncludeItem ::= SchemaLit &(';' | '}' | SpecExprStmt_first)
{
    extends = IncludeItem
}
AndIncludeItem ::= SchemaLit AndBinOp SchemaLit
{
    extends = IncludeItem
}
ImplyIncludeItem ::= <<includeStmtMode Expr>> ImplyBinOp SchemaLit
{
    extends = IncludeItem
}
IfElseIncludeItem ::= if Condition SchemaLit else SchemaLit
{
    extends = IncludeItem
}

SchemaLit ::= Path SchemaFieldsBlock?
{
    implements = [
        "org.move.lang.core.psi.MslOnlyElement"
    ]
}

SchemaFieldsBlock ::= '{' SchemaField_with_recover* '}' { pin = 1 }
private SchemaField_with_recover ::= !'}' SchemaLitField (',' | &'}')
{
    pin = 1
    recoverWhile = SchemaField_recover
}
private SchemaField_recover ::= !('}' | IDENTIFIER)

SchemaLitField ::= IDENTIFIER SchemaLitFieldInit?
{
    implements = [
        "org.move.lang.core.resolve.ref.MvSchemaRefFieldReferenceElement"
        "org.move.lang.core.psi.MslOnlyElement"
    ]
    mixin = "org.move.lang.core.psi.ext.MvSchemaLitFieldMixin"
}
private SchemaLitFieldInit ::= ':' Expr { pin = 1 }

private PatternVis ::= <<patternVisibility>>
private PatternIdent ::= <<patternIdent>>

FunctionPattern ::= PatternVis? PatternIdent TypeParameterList? {
    pin = 2
    implements = [
        "org.move.lang.core.psi.MslOnlyElement"
    ]
}

InvariantSpecExpr ::= invariant TypeParameterList? update? SpecPropertyList? Expr {
    pin = 1
    implements = [
        "org.move.lang.core.psi.MvBoolSpecExpr"
        "org.move.lang.core.psi.MslOnlyElement"
    ]
}

AxiomSpecExpr ::= axiom TypeParameterList? SpecPropertyList? Expr {
    pin = 1
    implements = [
        "org.move.lang.core.psi.MvBoolSpecExpr"
        "org.move.lang.core.psi.MvTypeParametersOwner"
        "org.move.lang.core.psi.MslOnlyElement"
    ]
}

SpecPropertyList ::= '[' SpecPropertyList_items? ']' {
    implements = [
        "org.move.lang.core.psi.MslOnlyElement"
    ]
}
private SpecPropertyList_items ::= SpecProperty (',' SpecProperty)* ','?

SpecProperty ::= !']' IDENTIFIER ('=' LitExpr)? &(',' | ']') {
    pin = 1
    implements = [
        "org.move.lang.core.psi.MslOnlyElement"
    ]
}

EmitsSpecExpr ::= emits SpecPropertyList? Expr to Expr EmitsCondition? {
    pin = 1
    implements = [ "org.move.lang.core.psi.MslOnlyElement" ]
}
EmitsCondition ::= if Expr {
    pin = 1
    implements = [ "org.move.lang.core.psi.MslOnlyElement" ]
}

ApplySchemaStmt ::= apply SchemaRef ApplyTo ApplyExcept? ';' {
    pin = 1
    implements = [ "org.move.lang.core.psi.MslOnlyElement" ]
}
ApplyTo ::= to <<non_empty_comma_sep_items FunctionPattern>> {
    pin = 1
    implements = [ "org.move.lang.core.psi.MslOnlyElement" ]
}
ApplyExcept ::= except <<non_empty_comma_sep_items FunctionPattern>> {
    pin = 1
    implements = [ "org.move.lang.core.psi.MslOnlyElement" ]
}

SchemaRef ::= Path ('{' <<non_empty_comma_sep_items ApplySchemaNameAttribute>> '}')?
{
    implements = [ "org.move.lang.core.psi.MslOnlyElement" ]
}
ApplySchemaNameAttribute ::= IDENTIFIER ':' Expr
{
    implements = [ "org.move.lang.core.psi.MslOnlyElement" ]
}

QuantWhere ::= where Expr
{
    pin = 1
    implements = [ "org.move.lang.core.psi.MslOnlyElement" ]
}

ForallQuantExpr ::= <<mslOnly forall>> QuantBindings QuantWhere? ':' Expr
{
    pin = 1
    rightAssociative = true
    implements = [
        "org.move.lang.core.psi.ext.MvQuantExpr"
        "org.move.lang.core.psi.MslOnlyElement"
    ]
}
ExistsQuantExpr ::= <<mslOnly exists>> QuantBindings QuantWhere? ':' Expr
{
    pin = 1
    rightAssociative = true
    implements = [
        "org.move.lang.core.psi.ext.MvQuantExpr"
        "org.move.lang.core.psi.MslOnlyElement"
    ]
}
QuantBindings ::= <<non_empty_comma_sep_items QuantBinding>>

// TODO: should be single QuantBinding, multiple are not allowed
ChooseQuantExpr ::= choose min? QuantBindings QuantWhere?
{
    pin = 1
    implements = [
        "org.move.lang.core.psi.ext.MvQuantBindingsOwner"
        "org.move.lang.core.psi.MslOnlyElement"
    ]
}
QuantBinding ::= RangeQuantBinding | TypeQuantBinding
{
    implements = [ "org.move.lang.core.psi.MslOnlyElement" ]
}

RangeQuantBinding ::= BindingPat in Expr {
    pin = 2
    extends = QuantBinding
}
TypeQuantBinding ::= BindingPat ':' Type {
    pin = 2
    extends = QuantBinding
}


///////////////////////////////////////////////////////////////////////////////////////////////////
// Meta rules
///////////////////////////////////////////////////////////////////////////////////////////////////

private gtgt   ::= <<gtgtImpl>>
private gteq   ::= <<gteqImpl>>
private ltlt   ::= <<ltltImpl>>
private lteq   ::= <<lteqImpl>>
private oror   ::= <<ororImpl>>
private andand ::= <<andandImpl>>
private eqeq_gt ::= <<eqeqgtImpl>>
private lt_eqeq_gt ::= <<lteqeqgtImpl>>

private dotdot ::= <<dotdotImpl>>

private meta non_empty_comma_sep_items ::= <<param>> ( ',' <<param>> )* ','?
